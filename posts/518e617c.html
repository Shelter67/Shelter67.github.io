<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><link rel=manifest href=/manifest.json><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>git | Shelter</title><meta name="author" content="Shelter"><meta name="copyright" content="Shelter"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介git是免费开源的分布式版本控制系统，版本控制系统分为集中式和分布式，集中式依赖中央服务器，但出现问题就会无法工作，分布式是每个人电脑上都有一个完整的版本库，可以在本地修改不需要考虑网络问题。 安装配置https:&#x2F;&#x2F;git-scm.com&#x2F; 123456789101112131415161718192021安装的时候看到这个(NEW!) Add a Git Bash Profile to W">
<meta property="og:type" content="article">
<meta property="og:title" content="git">
<meta property="og:url" content="http://localhost:4000/posts/518e617c.html">
<meta property="og:site_name" content="Shelter">
<meta property="og:description" content="简介git是免费开源的分布式版本控制系统，版本控制系统分为集中式和分布式，集中式依赖中央服务器，但出现问题就会无法工作，分布式是每个人电脑上都有一个完整的版本库，可以在本地修改不需要考虑网络问题。 安装配置https:&#x2F;&#x2F;git-scm.com&#x2F; 123456789101112131415161718192021安装的时候看到这个(NEW!) Add a Git Bash Profile to W">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.dreamshelter.cn/blog/source/img/cover/29.png">
<meta property="article:published_time" content="2025-10-25T19:04:00.000Z">
<meta property="article:modified_time" content="2026-02-09T10:05:53.763Z">
<meta property="article:author" content="Shelter">
<meta property="article:tag" content="git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.dreamshelter.cn/blog/source/img/cover/29.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "git",
  "url": "http://localhost:4000/posts/518e617c.html",
  "image": "https://cdn.dreamshelter.cn/blog/source/img/cover/29.png",
  "datePublished": "2025-10-25T19:04:00.000Z",
  "dateModified": "2026-02-09T10:05:53.763Z",
  "author": [
    {
      "@type": "Person",
      "name": "Shelter",
      "url": "https://github.com/Shelter67"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.dreamshelter.cn/blog/source/img/favicon.png"><link rel="canonical" href="http://localhost:4000/posts/518e617c.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#49b1f5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":3,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'git',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><style>#waifu { left: auto !important; right: 20px !important; }</style><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-veeink@1.0.7/lib/clock-min.css" /><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.1.1"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(https://cdn.dreamshelter.cn/blog/source/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/blog/source/img/touxiang.jpg" onerror="this.onerror=null;this.src='https://cdn.dreamshelter.cn/blog/source/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/zhuifan.html"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/zhuiju.html"><i class="fa-fw fas fa-video"></i><span> 追剧</span></a></div><div class="menus_item"><a class="site-page" href="/gongxianban"><i class="fa-fw fab fa-github-alt"></i><span> 贡献板</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.dreamshelter.cn/blog/source/img/cover/29.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Shelter</span></a><a class="nav-page-title" href="/"><span class="site-name">git</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/zhuifan.html"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/zhuiju.html"><i class="fa-fw fas fa-video"></i><span> 追剧</span></a></div><div class="menus_item"><a class="site-page" href="/gongxianban"><i class="fa-fw fab fa-github-alt"></i><span> 贡献板</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">git</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-25T19:04:00.000Z" title="发表于 2025-10-26 03:04:00">2025-10-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-09T10:05:53.763Z" title="更新于 2026-02-09 18:05:53">2026-02-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">15.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2026-02-09 18:05:53&quot;}" hidden></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>git是免费开源的分布式版本控制系统，版本控制系统分为集中式和分布式，集中式依赖中央服务器，但出现问题就会无法工作，分布式是每个人电脑上都有一个完整的版本库，可以在本地修改不需要考虑网络问题。</p>
<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p><a target="_blank" rel="noopener" href="https://git-scm.com/">https://git-scm.com/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">安装的时候看到这个(NEW!) Add a Git Bash Profile to Windows Terminal也推荐选择上</span><br><span class="line"></span><br><span class="line">安装了vscode可以选择Use Visual Studio Code as Git&#x27;s default editor，</span><br><span class="line"></span><br><span class="line">然后选main，</span><br><span class="line"></span><br><span class="line">然后Git from the command line and also from 3rd-party software，</span><br><span class="line"></span><br><span class="line">然后Use bundled OpenSsH，</span><br><span class="line"></span><br><span class="line">然后Use the openssL library，</span><br><span class="line"></span><br><span class="line">然后Checkout Windows-style，</span><br><span class="line"></span><br><span class="line">然后 Use MinTTY (the default terminal of MSYS2)，</span><br><span class="line"></span><br><span class="line">然后fast-forward or merge，</span><br><span class="line"></span><br><span class="line">然后Git Credential Manager</span><br><span class="line"></span><br><span class="line">Enable file system caching</span><br></pre></td></tr></table></figure>

<p>安装完输入这个</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看版本信息，有就是成功</span></span><br><span class="line">git -v</span><br></pre></td></tr></table></figure>

<p>Windows的话 安装完Git之后会自动安装Git Bash，鼠标右键有</p>
<p>git的使用方式有三种：命令行 图形化界面 和 IDE插件</p>
<p>命令行的方式是最基本和最常用的方式，就是在终端中输入Git命令的方式来使用Git。图形化界面也叫GUI，就是通过一些专用的图形化工具软件来使用Git，在Git官网上也可以找到常用的GUI工具。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251021035518780.png" alt="image-20251021035518780">IDE插件就是在常用的IDEA或者vscode这些IDE工具中，通过插件或者扩展的方式来使用git</p>
<p>为了区分Linux操作系统中的命令，Git的所有命令都以git开头，后面跟着具体的命令，比如 git init 就是初始化一个仓库</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251021035753626.png" alt="image-20251021035753626"></p>
<p>蓝色背景的部分是当前所在目录的位置，波浪线表示的是用户的主目录，比如我们现在所在的目录就是主目录下的directory这个目录下。绿色背景这里可以显示Git的分支名称和当前仓库的状态等信息，这个不配置也不影响使用</p>
<p>在开始使用Git之前第一步就是先使用 git config 命令配置一下用户名和邮箱，这样在提交的时候 才能够识别出来是谁提交的内容。这里的 –global参数表示的是全局配置，也就是说这个配置对所有的Git仓库都有效，不加这个参数就表示只对当前的Git仓库有效，还有一个就是 –system 参数表示系统级别的配置，对所有的用户都有效，一般不会使用–system</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251021040104117.png" alt="image-20251021040104117"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Liu Qi&quot;</span></span><br><span class="line">git config --global user.email 1830191738@qq.com</span><br></pre></td></tr></table></figure>

<p>这里因为用户名中间存在空格，所以需要使用双引号把它括起来，如果没有空格的话 这个双引号是可以省略的。配置完用户名之后 我们再来配置一下邮箱，那因为邮箱中间是没有空格的 所以就可以省略掉这个双引号。这两个命令只需要执行一次，执行过就可以省略</p>
<p>我们还可以使用下面这个命令来保存用户名和密码，这样就不用每次都输入了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<p>我们也可以使用下面这个命令来查看Git的配置信息，可以看到刚刚我们配置的用户名和邮箱，配置完成之后 我们就可以使用Git来管理我们的代码了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>

<h1 id="新建版本库"><a href="#新建版本库" class="headerlink" title="新建版本库"></a>新建版本库</h1><p>版本库又叫仓库，英文名叫Repository简称Repo，大家可以把仓库理解成一个目录，这个目录里面所有的文件都可以被Git管理起来，每个文件的修改 删除 添加等操作Git都能够跟踪到，以便任何时候都可以追踪历史或者还原到之前的某一个版本。</p>
<p>创建仓库：方式1，git init。方式2,，git clone</p>
<p>​	只需要把一个目录变成Git可以管理的仓库就可以了，一种是在自己电脑本地直接创建一个仓库，另	一种是从远程服务器上克隆一个已经存在的仓库</p>
<ol>
<li>首先需要找到一个合适的位置来创建一个空目录，比如这里我们就创建一个叫做 learn-git 的目录，后面课程中的所有操作也都会在这个目录下进行，然后输入git init就可以创建一个仓库了，然后提示我们已经初始化了一个空的仓库和位置，命令行前面提示符的部分也变成了main，这个 main 就是当前所在的分支的名称，表示当前这个目录已经是一个被Git管理的仓库，然后ls -a来看一下这个目录下到底有没有一个叫.git 的目录，因为.git是隐藏文件所以加-a</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> learn-git</span><br><span class="line"><span class="built_in">cd</span> learn-git</span><br><span class="line">git init（输出Initialized empty Git repository <span class="keyword">in</span> F:/learn-git/.git/</span><br><span class="line"><span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure>

<p>git 这个目录存放了Git仓库的所有数据，用下面两个命令可以看到很多文件和目录，这里都是重要文件不要随意修改，删除这个目录等于删除仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .git</span><br><span class="line"><span class="built_in">ls</span> -altr</span><br></pre></td></tr></table></figure>

<p>git init 后面还可以指定目录的名称，如果指定了就会在当前目录下面创建一个新的目录作为Git仓库，比如我们可以创建一个叫做my-repo的Git仓库，会在learn-git后面的 my-repo 里面生成了一个.git目录，也就是说 my-repo 才是我们创建的仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init my-repo</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 git clone 命令来从Github 或者 Gitee这种远程服务器上来克隆一个已经存在的仓库，直接在命令行中输入 git clone 后面加上仓库的地址。可以看到除了 my-repo 这个仓库以外又多了一个remote-repo 这样的目录，进入后它也是显示了一个绿色的main 分支，再-a看一下也是有一个.git 的目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/geekhall-laoyang/remote-repo.git</span><br><span class="line"><span class="built_in">ls</span> -ltr（按大小排序的长格式列表，降序</span><br><span class="line"><span class="built_in">cd</span> remote-repo</span><br></pre></td></tr></table></figure>

<h1 id="Git的工作区域和文件状态"><a href="#Git的工作区域和文件状态" class="headerlink" title="Git的工作区域和文件状态"></a>Git的工作区域和文件状态</h1><p>Git的本地数据管理分为工作区 暂 存区和本地仓库，工作区域英文名叫 Working Directory，也叫工作目录或者本地工作目录，暂存区英文名叫 Staging Area，也称为索引index，是一种临时存储区域，用于保存即将提交到Git仓库的修改内容，暂存区域是在Git进行版本控制时非常重要的一个区域，本地仓库就是我们上一节课通过 git init 命令创建的那个仓库，它包含了完整的项目历史和元数据，是Gi存储代码和版本信息的主要位置</p>
<p>当你修改完工作区的文件之后需要将它们添加到暂存区，然后再将暂存区的修改提交到本地仓库中，这个过程中我们可以使用Git提供的命令来查看 比较或者撤销修改，来保证版本控制的准确性和完整性</p>
<p>举个例子，我们可以把仓库理解成工厂里面的<strong>仓库</strong>，这个仓库里面有很多的货物和产品，这些<strong>货物和产品</strong>就是我们的<strong>文件</strong>，比如说我们的代码文件 文本文件 图片文件等等，<strong>工作区</strong>就是<strong>生产</strong>这些货物的车间，对我们的货物进行生产 加工和修改，车间生产完这些产品之后需要运送到仓库里面保管起来。那车间和仓库之间需要有一个运输工具，比如我们使用小货车来运输的话，那这个<strong>小货车</strong>里面就是<strong>暂存区</strong>，车间生产完产品之后把产品放到小货车上，然后运输到仓库里面保存起来</p>
<p>联系到工作中，当我们的代码完成了一个阶段想存档备份的时候，就可以把这个版本放到本地仓库里面保存起来，在版本控制系统中，这个保存到仓库中的过程就叫做<strong>提交</strong>。但是如果我们每次文件修改之后都需要进行一次提交的话会比较麻烦，git提供一种方式：可以将修改的文件先添加到暂存区中，然后再把所有暂存区中的文件统一执行一下提交操作。联想到我们刚刚的例子的话，就是我们的车间生产完货物之后，并不是每次都需要运送到仓库里面，而是先把这些货物放到小货车上，然后一次性的运送到仓库里面保存起来。</p>
<p>相应的 Git中的文件也存在几种状态，分别是未跟踪 未修改 已暂存 已提交</p>
<p>未跟踪就是我们新创建的还没有被Git管理起来的文件，未修改就是我们已经被Gt管理起来但是文件的内容没有发生变化，还没有被修改过。已修改就是我们修改了文件，但是还没有添加到暂存区里面。已暂存就是我们修改后并且已经添加到了暂存区域内的文件，联想到刚刚的例子也就是已经放到小货车里面的货物</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251021224351090.png" alt="image-20251021224351090"></p>
<h1 id="添加提交仓库"><a href="#添加提交仓库" class="headerlink" title="添加提交仓库"></a>添加提交仓库</h1><p><strong>git status</strong></p>
<p>status这个单词本身就是状态的意思，用于查看仓库的状态，比如可以查看当前仓库处在哪个分支、有哪些文件以及这些文件当前处在怎样的一个状态，使用后可能会看到自己的分支名称是 master 而不是main，这是由于Git的版本不同导致的，没什么事</p>
<p>首先创建一个文件，创建文件有很多种方式，用熟悉的就行，这里直接使用 Linux 下的 echo 命令，将回显的内容输出到一个文件里面，比如输出一个“这是第一个文件”，可以看到 本地已经多一个file.txt的文件，看一下这个文件里面的内容可以看到刚刚输入的内容已经被写入到这个文件里面了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-repo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;这是第一个文件&quot;</span> &gt; file.txt</span><br></pre></td></tr></table></figure>

<p>再来看一下仓库的状态，可以看到命令的回显中比刚才多了一红色的文件，就是刚刚新建的文件，这个文件现在就是处在一个未被跟踪的状态，接下来就可以使用 git add 命令来把文件放到小货车里面，这个命令的作用就是将文件添加到暂存区，等待后续的提交操作。</p>
<p>再来看一下仓库的状态，可以看到刚刚红色的 filext已经变成了绿色，表示这个文件现在已经被添加到了暂存区等待被提交，提示符里面也多了一个加号（我这里没显示），表示我们的仓库中存在已经修改了但是没有提交的文件，下面括号里面还有这样一行提示  (use “git rm –cached <file>…” to unstage)，他告诉我们可以使用这样的命令来把添加到暂存区的文件再取消暂存，也就是可以把刚刚放到小货车里面的货物再拿回来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add file.txt</span><br><span class="line"></span><br><span class="line">git status</span><br></pre></td></tr></table></figure>

<p><strong>git commit</strong></p>
<p>commit就是提交的意思，我们的文件只有被提交到仓库中才算真正的被保管起来，这里有一个需要注意的地方就是 git commit 这个命令只会提交暂存区中的文件而不会提交工作区中的其他文件，比如我们现在再来创建一个新的文件，然后再来看一下仓库的状态，可以看到刚刚创建的这个 file2是红色的未跟踪的状态，然后提交一下，注意git commit 这个命令在提交的时候需要使用 -m 参数来指定提交的信息，这个信息会被记录到仓库中，如果不指定 -m 这个参数，那么git commit 命令会进入一个交互式的界面，默认会使用:vim 来编辑提交信息。提交完成之后再看看仓库状态，刚刚绿色的 filetxt已经不见了，这是因为我们已经把file提交到仓库里面保管起来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;这是文件2的内容&quot;</span> &gt; file2.txt</span><br><span class="line">git status</span><br><span class="line">git commit -m <span class="string">&quot;第一次提交&quot;</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure>

<p><strong>git add</strong> 命令还可以使用通配符来添加多个文件，为了演示通配符的使用 我们再来多添加几个文件，然后可以看到仓库里面有四个txt文件和一个以sh结尾的shell脚本文件，执行git status可以看到除了file己经被仓库保管起来之外下面四个新建的文件都处于一个未跟踪的状态，可以使用 git add *.txt来把所有以txt结尾的文件都添加到暂存区里面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;file3&quot;</span> &gt; file3.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;file4&quot;</span> &gt; file4.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;file5&quot;</span> &gt; file5.sh</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">git status</span><br><span class="line">git add *.txt</span><br></pre></td></tr></table></figure>

<p>git add 命令还可以接受文件夹作为参数，比如想要添加所有文件的话可以使用 git add.这个命令来把当前文件夹下的所有文件都添加到暂存区里面，这里的点就表示当前目录，这次我们不输入-m参数，Git就会自动地进入一个交互式界面，默认会使用vim来编辑提交信息，可以使用方向键来移动光标，t使用i键进入编辑模式，安装的时候好像设置成了vscode启动了，输入这是第二次提交然后保存退出提交，再看一下状态提示我们所有的文件都提交完成了</p>
<p><strong>git log</strong></p>
<p>可以使用 git log 命令来查看提交记录。每次提交都有一个唯一的提交ID，就是 commit 后面这个16进制的字符串，还有每次提交的作者和邮箱以及提交的时间和刚刚提交时编写的注释信息等等内容，这里的名字和邮箱就是我们使用 git config 命令配置的，git log 后面还可以接收一些参数，比如说可以使用 git log 后面加上 –oneline来查看简洁的提交记录，这样就只显示每次提交的 ID 和提交信息了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line">git status</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>

<h1 id="git-reset回退版本"><a href="#git-reset回退版本" class="headerlink" title="git reset回退版本"></a>git reset回退版本</h1><p>reset 命令用于回退版本，可以退回到之前的某一个提交的状态</p>
<p>git reset的三种模式：git rese –soft、git rese –hard、git rese –mixed，也就是软的 硬的和混合的</p>
<p>soft 参数表示回退到某一个版本并且保留工作区和暂存区的所有修改内容，hard 的参数表示回退到某一个版本并且丢弃工作区和暂存区的所有修改内容，mixed 这个参数就是介于 soft 和 hard 这两个参数之间，它表示回退到某一个版本并且只保留工作区的修改内容而丢弃暂存区的修改内容，mixed 也是 reset 命令的默认参数</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251022031628912.png" alt="image-20251022031628912"></p>
<p>例子：首先来新建一个仓库 并且添加几次提交内容，提交完来使用 git log 查看一下提交历史，然后这个时候如果我们想要回退到上一个版本的话就可以使用 git reset 命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git init repo</span><br><span class="line"><span class="built_in">cd</span> repo</span><br><span class="line"><span class="built_in">echo</span> 111 &gt; file1.txt</span><br><span class="line"><span class="built_in">echo</span> 222 &gt; file2.txt</span><br><span class="line"><span class="built_in">echo</span> 333 &gt; file3.txt</span><br><span class="line">git add file1.txt</span><br><span class="line">git commit -m <span class="string">&quot;commit1&quot;</span></span><br><span class="line">git add file2.txt</span><br><span class="line">git commit -m <span class="string">&quot;commit2&quot;</span></span><br><span class="line">git add file3.txt</span><br><span class="line">git commit -m <span class="string">&quot;commit3&quot;</span></span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>

<p>为了方便演示再打开一个终端，然后把这个仓库目录复制三份，分别来执行三种不同的参数</p>
<p>首先我们来看一下 soft 参数，直接在命令行输入 git reset –soft，后面加上要回退的版本ID就可以了，回车之后再来使用 git log 查看一下提交历史，可以看到现在提交历史只有两次了，HEAD 指针也指向了第二个版本，那再来看一下工作区和暂存区的内容，使用ls命令查看一下工作区的内容，可以看到 file3 这个文件还在，cat 命令查看一下 file3 的内容也是没有问题的，file3在暂存区里面也是存在的</p>
<p>再来看一下仓库的状态，提示我们 file3 是一个新文件，因为我们使用的是 soft 参数，所以回退到上一个版本的时候，工作区和暂存区的内容都不会被清空，所以file3这个文件还是存在的，但是因为回退到了第二个版本，而file3这个文件是在第三个版本才添加的，所以对于第二个版本来说i这个file3文件就是一个新文件，这个时候我们就可以修改一下file3的内容，然后重新添加暂存和提交一下就可以了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> f:/learn-git</span><br><span class="line"><span class="built_in">cp</span> -rf repo repo-soft</span><br><span class="line"><span class="built_in">cp</span> -rf repo repo-hard</span><br><span class="line"><span class="built_in">cp</span> -rf repo repo-mixed</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> repo-soft</span><br><span class="line">git reset --soft 7f644ae</span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line">clear</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">cat</span> file3.txt</span><br></pre></td></tr></table></figure>

<p>hard参数，这里我们也是回退到上一个版本，使用 HEAD 加上尖角号来表示上一个版本，回车之后再使用 git log 查看一下提交历史，可以看到现在提交历史也是只有两次了，这个和 soft 参数是一样的，再来看一下工作区和暂存区的内容，ls命令查看一下工作区的内容，能够看到file3这个文件已经不存在了，再来查看一下暂存区的内容也没有了</p>
<p>就是说如果我们使用 hard 参数回退到上一个版本的时候，工作区和暂存区的内容都会被清空</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> learn-git</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">cd</span> repo-hard</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="built_in">ls</span> （file3不存在</span><br><span class="line">git ls-files（暂存区没有</span><br></pre></td></tr></table></figure>

<p>最后再来看一下默认的 mixed 参数，同样回退，这次我们不加任何参数直接输入 git reset，回车之后再来使用 git log 查看一下提交历史，可以看到现在提交历史也是只有两次，在工作区和暂存区file3这个文件还是存在的，cat命令查看内容也是没有问题的，然后再查看一下暂存区的内容，可以看到暂存区里面已经没有file3这个文件了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> learn-git</span><br><span class="line"><span class="built_in">cd</span> repo-mixed</span><br><span class="line">git reset HEAD^</span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">cat</span> file3.txt</span><br><span class="line">git ls-files</span><br></pre></td></tr></table></figure>

<p>在使用场景方面soft和 mixed 的作用基本相似，区别就在于是否保留暂存区的内容，一般来说当我们连续提交了多个版本，但是又觉得这些提交没有太大意义可以合并成一个版本的时候，就可以通过这两个参数来进行回退之后再重新提交</p>
<p>那它们主要的区别就是在重新提交之前，混合模式需要执行一下get add操作来将变动的内容重新添加到暂存区，而soft模式就不需要了，因为暂存区并没有被清空，而hard参数的使用场景则一般是真的要放弃目前本地所有修改内容的时候，建议大家谨慎使用,hard.这个参数，因为它会删除这两个版本之间的工作区和暂存区的所有修改内容</p>
<p>如果不小心误操作的话也不用太担心，Git中的所有操作都是可以回溯的，可以使用git reflog 命令来查看一下我们操作的历史记录，然后找到误操作之前的版本号再使用 git reset 命令来回退到这个版本就可以了</p>
<h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><p>它可以用来查看文件在工作区 暂存区以及版本库之间的差异，它还可以查看文件在两个特定版本之间的差异，或者文件在两个分支之间的差异，平时我们开发的时候更多的是使用一些图形化的工具，但是需要了解一下这个，因为有的时候我们需要在一些没有图形化工具的服务器上来使用Git</p>
<p>git diff 后面如果什么都不加的话，会默认比较的是工作区和暂存区之间的差异内容，它会显示发生更改的文件以及更改的详细信息</p>
<p>演示：还是使用上面创建的仓库，这个仓库目前有三次提交，每次提交都新增了一个文件，比如第一次提交新增了一个file1.txt 里面是三个1以此类推，然后来修改一下file3这个文件，把文件内容改成 一键三连了吗，然后保存退出，能够看到现在终端的命令提示符已经变成了黄色，表示我们修改了一些仓库中的内容。那现在我们使用 git diff 命令来查看一下</p>
<p>第一行提示了我们发生变更的文件，第二行解释：Git会将文件的内容使用哈希算法生成一个40位的哈希值，这里只显示了哈希值的前七位，后面的100644表示的是文件的权限，再往下就是刚刚修改的内容了，红色是删除内容绿色是添加，现在比较的是工作区和暂存区之间的差异，因为我们修改的内容还没有被添加到暂存区，我们添加一下 ，然后再来使用 git diff 看一下输出结果，可以看到没有任何内容了，表示我们的工作区和暂存区的内容是相同的</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251023035448689.png" alt="image-20251023035448689"></p>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251023035614918.png" alt="image-20251023035614918" style="zoom: 33%;" />

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi file3.txt</span><br><span class="line">git diff </span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git diff</span><br></pre></td></tr></table></figure>

<p>除了比较工作区和暂存区之间的差异以外，还可以比较工作区和版本库之间的差异，在命令后面加上 HEAD 就可以了，比如我们现在添加的内容还没有提交到仓库里面，那么这个差异内容就应该是存在的，刚刚我们修改的内容又被显示出来了，这是因为我们还没有执行提交操作，所以工作区和版本库的内容是不相同的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure>

<p>我们还可以比较暂存区和版本库之间的差异，方法就是给 diff 后面加上 cached 这个参数，可以看到输出内容是相同的，那我们现在来提交一下，然后再来看一下 git diff 的内容，可以看到没有任何输出了，表示我们的工作区 暂存区和版本库的内容是一致的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff --chached</span><br><span class="line">git commit -m <span class="string">&quot;commit4&quot;</span></span><br><span class="line">git diff --chached（没有任何输出</span><br><span class="line">git diff HEAD（没有任何输出</span><br></pre></td></tr></table></figure>

<p>还可以用来比较两个特定版本之间的差异，用法就是在后面加上想要比较的两个版本的提交ID就可以了，先来看一下当前仓库的提交记录，然后git diff 后面加上两次版本的提交ID就可以比较这两个版本之间的差异内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline（查看提交<span class="built_in">id</span></span><br><span class="line">git diff xxx xxx</span><br></pre></td></tr></table></figure>

<p>除了使用提交ID之外还可以使用 HEAD 来表示当前分支的最新提交，HEAD 是 Git 中的一个非常重要的概念，它指向分支的最新提交节点，我们也可以使用某一个版本的提交ID和 HEAD 来进行比较，比如使用上一个，就是 git dif 第一个版本的提交ID，后面加上 HEAD 表示第二个版本，然后回车就可以了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff xxx HEAD</span><br></pre></td></tr></table></figure>

<p>当然如果每次都要查看提交ID的话有些麻烦，那最经常用到的就是比较当前版本和上一个版本之间的差异，这里 Git 也为我们提供了一个更加简便的方式，就是我们可以使用 HEAD 加上波浪线来表示上一个版本，刚刚的比较就可以替换成HEAD 加上波浪线，然后后面再加上HEAD，可以看到结果是一样的，除了使用波浪线以外 尖角号也是可以的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD~ HEAD</span><br><span class="line">git diff HEAD^ HEAD</span><br></pre></td></tr></table></figure>

<p>还可以在波浪线后面加上具体的数字，比如我们加上波浪线 3就表示 HEAD 之前的第三个版本，也就是commit1， 除了我们刚刚的修改以外，上一个版本的差异内容也被显示出来了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD~3 HEAD</span><br></pre></td></tr></table></figure>

<p>git diff 后面还可以加上文件名，这样就只会查看这个文件的差异内容，比如我们在刚刚的命令后面加上file3，这样就只会查看fle3的差异内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD~3 HEAD file3.txt</span><br></pre></td></tr></table></figure>

<p>git diff 还可以查看两个分支之间的差异，直接加上两个分支名就可以了，后面再讲解</p>
<h1 id="git-rm-删除文件"><a href="#git-rm-删除文件" class="headerlink" title="git rm 删除文件"></a>git rm 删除文件</h1><p>删除文件有两种常用的方式</p>
<p>一：直接删除文件之后提交，首先来看一下本地仓库中的文件内容，比如这里我们就来删除 file1.txt 这个文件，需要使用 rm 命令在本地工作区中删除文件，执行 rm file1.txt，注意这里的 rm 并不是 Git 的命令而是Linux操作系统的命令</p>
<p>然后我们来看一下文件是否被删除了，可以看到 file1.txt 已经被删除掉了，然后再来看一下仓库的状态，这里它提示我们file1.txt 已经被删除了，它还提示我们需要使用 git add 来更新暂存区，这里为什么要添加到暂存区？因为刚刚我们只是在本地工作区删除了文件，而暂存区中的文件还没有被删除。可以使用 git ls-files 这个命令来查看暂存区中的内容，可以看到这个file1.txt 仍然在暂存区中并没有被删除掉，那这里的 git add命令就可以理解成告诉Git要删除这个文件，你可以先把这个文件从暂存区中也删除掉，可以使用git add file1.txt，也可以直接使用git add .</p>
<p>执行完之后再来查看一下暂存区中的文件内容可以看到 file1.txt已经不在了，这个方法还是有点麻烦的，那Git 也为我们提供了另外一个方法，就是可以使用 git rm 这个命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-repo</span><br><span class="line"><span class="built_in">ls</span> -ltr</span><br><span class="line"><span class="built_in">rm</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">git status</span><br><span class="line">git ls-files</span><br><span class="line">git add .</span><br><span class="line">git ls-files</span><br></pre></td></tr></table></figure>

<p>git rm：我们来把file2.txt这个文件从版本库中也删掉，那直接使用 git rm file2.txt，Git就把这个文件从工作区和暂存区同时删除掉了，最后非常重要的一点就是要记得提交，否则删除的文件在版本库中还是存在的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> file2.txt</span><br><span class="line">git status（查看仓库</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">git ls-files查看暂存区</span><br><span class="line">git commit -m <span class="string">&quot;delete file1.txt and file2.txt&quot;</span></span><br></pre></td></tr></table></figure>

<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251024030253586.png" alt="image-20251024030253586" style="zoom: 50%;" />

<h1 id="gitignore忽略文件"><a href="#gitignore忽略文件" class="headerlink" title=".gitignore忽略文件"></a>.gitignore忽略文件</h1><p>这个文件的作用也就是可以让我们忽略掉一些不应该被加入到版本库中的文件，这样可以让我们的仓库体积更小 更加干净，那么哪些文件是不应该被纳入到版本库中的呢</p>
<ul>
<li>系统或者软件自动生成的文件，比如一些工具或者软件产生的临时文件</li>
<li>编译生成的一些中间文件 可执行文件等等，也就是如果一个文件是通过另一个文件自动生成的，比如 Java 编译生成的.class文件，C语言编译生成的.o文件</li>
<li>系统运行过程中自动生成的一些文件，比如日志文件 缓存文件或者临时文件等等</li>
<li>带有敏感信息的一些配置文件，这些文件里面如果包含用户名 密码 Token 的话一定不要放到版本库里面</li>
</ul>
<p>可以在这个文件中列出需要忽略的文件的模式，这样这些文件就不会被提交到版本库中</p>
<p>我们先来创建一个 access.log 来模拟一下我们的日志文件，那现在如果我们什么都不做的话这个文件就会被纳入到版本控制中，继续使用git add然后再git commit 提交的话，那access.log这个文件就会被提交到我们的版本仓库里面</p>
<p>为了对比，我们再创建第二个日志文件，可以看到我们现在有两个日志文件，那现在我们添加一个gitignore文件，我们把access.log添加到.gitignore这个文件里面，可以看到这个文件里面只有一行内容，然后我们再来使用 git status 来看一下，可以看到现在只能看到 other.log 这个文件，而access.log这个文件已经看不到了，这样我们就忽略了access.log文件。</p>
<p>使用 git add .把所有的修改都添加到暂存区，然后我们来提交一下，可以看到 other.log这个文件已经被我们添加到了版本库里面，而accesslog这个文件却没有被添加进来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;some log&quot;</span> &gt; access.log</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;other log&quot;</span> &gt; other.log</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> access.log &gt; .gitignore</span><br><span class="line"><span class="built_in">cat</span> .gitignore（输出access.log</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git status</span><br><span class="line">git commit -m <span class="string">&quot;ignore file sample&quot;</span></span><br><span class="line">git ls-files</span><br></pre></td></tr></table></figure>

<p>我们也可以使用*.log这样的通配符来匹配所有以log结尾的文件，那我们现在来修改一下点 .gitignore文件，我们在下面加上一行*.log表示我们忽略所有的以log结尾的文件，然后我们再来添加一个日志文件，使用 git status 来看一下状态，我们现在只能看到,gitignore这个文件的修改，而 hello.log 的修改被我们忽略掉了，然后再提交一下，然后我们再来看一下我们版本库中的文件，可以看到 hello.log 这个文件也是没有被添加进来的，表示我们*.log 成功的适配了所有的 *.log结尾的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi .gitignore</span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line"><span class="built_in">echo</span> hell0 &gt; hello.log</span><br><span class="line">git status(只有.gitignore)</span><br><span class="line">git commit -m <span class="string">&quot;test ignore log&quot;</span></span><br><span class="line">git ls-files</span><br></pre></td></tr></table></figure>

<p><strong>小知识点</strong>：如果对已经添加到仓库的other.log 这个文件做一些修改的话，Git还会不会监测到它的版本变化呢？</p>
<p>比如我们在other.log文件里面追加一些内容，两个右箭头在Linux 命令里面表示追加到这个文件的后面，那我们现在使用 git status 来看一下它的状态，Git还是提示我们other.log 这个文件发生了变化，而且我们使用 gitdiff这个命令也是可以看到它的变化内容的</p>
<p>.gitignore文件生效需要有一个前提，就是这个文件不能是已经被添加到版本库中的文件，那这个时候我们就需要把other.log 这个文件先从版本库中先删除掉，使用git rm 命令会把文件从工作区和暂存区同时删除，如果我们只是想把它从版本库里面删除而不想删除本地文件的话，就可以在后面加上–cached的这个参数，然后我们来看一下仓库的状态，它提示我们 other.log这个文件已经被删除了，然后我们再来看一下本地文件，可以看到在本地没有被删除。然后再提交一下，这样以后无论这个文件发生了什么变化就都不会被纳入到版本控制中了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot; modified &quot;</span> &gt;&gt; other.log</span><br><span class="line"> git status </span><br><span class="line"> git diff</span><br><span class="line"> git <span class="built_in">rm</span> --cached other.log</span><br><span class="line"> git status</span><br><span class="line"> <span class="built_in">ls</span></span><br><span class="line"> git commit -am <span class="string">&quot;delete other.log&quot;</span></span><br></pre></td></tr></table></figure>

<p>.gitignore文件中还可以配置文件夹的名称，比如这里我们创建一个 temp 文件夹，用来存放一些临时文件，小<strong>知识点</strong>：如果temp文件夹下面什么都没有的话，这个文件夹是不会被纳入到版本控制中的，因为Git默认是不会将空的文件夹添加到仓库里面的，这个时候如果我们使用 git status 命令也是看不到任何变化的，temp文件夹下面有文件的话就会被纳入到版本控制中</p>
<p>比如我们来添加一个hello 到temp&#x2F;hello，再来使用git status -s这个命令来看一下仓库的状态，-s是 short 的缩写，表示查看状态这个命令的简略模式，这个命命的回显最前面有两个问号，这里的两个间号第一列表示是暂存区的状态，第二列表示工作区的状态，然后我们在 .gitignore文件中添加 temp 文件夹的名称，这样我们就忽略了 temp 文件夹，注意文件夹的格式是以斜线结尾的，保存退出然后再来看一下仓库的状态，可以看到temp文件夹已经被忽略掉 不显示了，那这里的 M 表示.gitignore文件被修改过，然后提交，我们看一下仓库的文件内容，可以看到 temp 文件夹以及它下面的所有文件并没有被提交到我们的仓库里面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> temp</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; temp/hello.txt</span><br><span class="line">git status -s(输出?? temp/)</span><br><span class="line">vi .gitignore</span><br><span class="line">temp/</span><br><span class="line">:wq</span><br><span class="line">git status -s（输出 M.gitignore）</span><br><span class="line"> git commit -am <span class="string">&quot;test ignore folder&quot;</span></span><br><span class="line"> git ls-files</span><br></pre></td></tr></table></figure>

<p>.gitignore文件的匹配规则：gitignore 这个配置文件是按行从上到下进行规则匹配的，忽略文件的匹配规则在Git官网上有详细的说明<a target="_blank" rel="noopener" href="https://git-scm.com/docs/gitignore">https://git-scm.com/docs/gitignore</a></p>
<ul>
<li><p>空行或者以#开头的行会被Git忽略。一般空行用于可读性的分隔,#一般用作注释</p>
</li>
<li><p>使用标准的Blob模式匹配,所谓的 glob 模式就是指 she!ll所使用的简化了的正则表达式，例如:</p>
<ul>
<li>星号*通配任意个字符</li>
<li>问号 ?匹配单个字符</li>
<li>中括号[]表示匹配列表中的单个字符,比如:[abc] 表示a&#x2F;b&#x2F;c</li>
</ul>
</li>
<li><p>两个星号 **表示匹配任意的中间目录</p>
</li>
<li><p>中括号可以使用短中线连接，比如:</p>
<ul>
<li>[0-9] 表示任意一位数字,[a-z]表示任意一位小写字母</li>
</ul>
</li>
<li><p>感叹号 ! 表示取反，要忽略指令模式以外的文件或者目录可以在模式前加上感叹号就可以了</p>
</li>
</ul>
<p>例子：</p>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025032738511.png" alt="image-20251025032738511" style="zoom:50%;" />

<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025032750272.png" alt="image-20251025032750272" style="zoom:50%;" />

<p>在Github上提供了各种常用语言的忽略文件的模板，在新建仓库的时候我们可以直接使用</p>
<h1 id="注册github账号"><a href="#注册github账号" class="headerlink" title="注册github账号"></a>注册github账号</h1><p>略</p>
<h1 id="SSH配置和克隆仓库"><a href="#SSH配置和克隆仓库" class="headerlink" title="SSH配置和克隆仓库"></a>SSH配置和克隆仓库</h1><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025033200128.png" alt="image-20251025033200128"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025033210748.png" alt="image-20251025033210748"></p>
<p>然后点击头像，下面有一个绿色的创建仓库的按钮，点击就可以新建一个仓库了，我们需要填写一下仓库的名称，下面是一个可选的仓库的描述，比如我们就叫Myfirst repo，再下面是选择仓库的可见性，再往下是选择是否初始化个README文件，这个文件是用来介绍我们的仓库的，自行选择，后面可以手动添加。再住下是选择是否创建一个gitignore文件，那再下面就是开源许可证的文件，这里我们也暂时先不选择，然后点击最下面的新建仓库按钮就可以创建。</p>
<p>创建完成之后就跳转到了我们仓库的主页面，github给了提示让我们知道如何把本地仓库和这个远程仓库关联起来，第一个方法是如果我们本地没有仓库的话可以先在本地创建一个仓库，按照命令就可以把本地仓车和这个远程仓库关联起来。第二个方法就是如果我们本地已经有了一个仓库的话应该怎么操作。最后一个是提示我们还可以导入其他的仓库，比如可以将原本使用SVN或者其他平台的一些仓库导入进来</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025034133510.png" alt="image-20251025034133510"></p>
<p>这是远程仓库地址的两种方式，HTTPS开头的这种方式在我们把本地代码push到远程仓库的时候需要验证用户名和密码，而git开头的这种方式使用的是SSH协议，这种方式在推送的时候不需要验证用户名和密码，但是需要在GtHub上添加SSH公钥的配置，这种也是比较推荐的方式。在2021年8月13日以后https的这种方式已经被GtHub停止使用了，所以这里推荐大家使用SSH的方式</p>
<p>我们复制一下仓库的地址，然后回到本地使用git clone命令加上仓库的地址来克隆仓库，报错提示我们请确认是否有正确的访问权限，这是由于我们还没有配置SSH密钥导致的，使用SSH方式必须要配置SSH的密钥</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:shelterlq77-bit/shelter.git</span><br></pre></td></tr></table></figure>

<p>首先回到我们的用户根目录，然后进入到.ssh这个目录，然后我们使用ssh-keygenerate 这个命令来生成我们的SSH密钥，后面加上-t指定协议为RSA，再加上-b指定生成的大小为4096，然后回车，它提示我们需要输入密钥的文件名称，这里大家需要注意，如果你是第一次使用这个命令的话那么直接回车就可以，它会在我们用户根目录的点SSH目录下生成一个id_rsa的密钥文件</p>
<p>但是如果之前已经配置过SSH密钥了那这个时候最好不要直接回车，因为老师之前已经生成过id_rsa这个密钥文件，如果再次回车会覆盖并且不可逆，所以这里需要输入一个新的文件名，比如test然后回车输入密码，这样就完成了。</p>
<p>查看一下，没有任何扩展名的这个test就是私钥文件，不要给别人，而以.pub结尾的这个文件就是公钥文件，我们需要打开公钥文件然后复制一下公钥文件的内容，回到GitHub页面点一下右上角的头象，settings，在页面左侧有一个SSH和GPG密钥配置的选项，在页面石则有一个新建SSH密钥的按钮，点击然后把刚刚复制的公钥内容粘贴到下面的输入框中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span> .ssh（如果没有就需要创建，~ 代表你的用户主目录（如 C:\Users\你的用户名））</span><br><span class="line"><span class="built_in">mkdir</span> ~/.ssh（创建）</span><br><span class="line">ssh-keygen -t rsa -b 4096（如果之前生成过就输入一个文件名）</span><br><span class="line"><span class="built_in">ls</span> -ltr</span><br><span class="line">vi id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>回到命令行终端，如果你是第一次创建SSH密钥而且在创建密钥的时候也没有修改过默认的文件名的话，SSH密钥的配置到这里就完成了。如果刚刚指定了一个新的文件名那么还需要增加一步配置，我们需要创建一个config文件，并把下面这5行内容添加到文件里面。这个配置文件的意思是当我们访问github.com的时候指定使用SSH下的test这个密钥</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -5 config</span><br><span class="line"><span class="comment"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/test</span><br></pre></td></tr></table></figure>

<p>然后我们回到本地仓库再来执行一下 git clone 命令，这里它提示我们需要输入密码，如果创建秘钥的时候没有输入密码，那么这里也直接回车即可，然后就成功了。这个命令的意思就是把远程仓库克隆到本地，克隆成功我们就可以看到本地多了一个remote-repo （我这里是shelter）的目录，进入里面，发现我们的提示符变成了绿色表示这是一个Git仓库，然后我们再来添加一个文件，然后添加到暂存区 再提交一下，再使用git ls-files来看一下我们的仓库状态，确实多了一个文件，但只是本地的并没有提交到远程仓库中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> shelter</span><br><span class="line"><span class="built_in">echo</span> hello &gt; hello.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git ls-files</span><br></pre></td></tr></table></figure>

<p>这里稍微解释一下，Git是一种分布式的版本控制系统，我们的本地仓库和远程仓库是两个仓库，它们之间是相互独立的，我们可以在本地仓库中做任何修改，但是这些修改并不会影响到远程仓库，反之亦然。因此我们需要一种机制来同步本地仓库和远程仓库的修改内容，让他们的状态保持一致，pull和push，一个表示拉取 一个表示推送。push就是把本地仓库的修改推送给远程仓库，pull就是把远程仓库的修改拉取到本地仓库，刚刚我们在本地仓库新建了一个文件，但是这个文件并没有同步给远程仓库，下面就使用push命令来把本地仓库的修改内容推送给远程仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>推送命令执行成功了，打开页面Ctr+shit+R刷新一下，可以看到 hello.txt 这个文件已经推送到了GtHub上</p>
<h1 id="关联本地仓库和远程仓库"><a href="#关联本地仓库和远程仓库" class="headerlink" title="关联本地仓库和远程仓库"></a>关联本地仓库和远程仓库</h1><p>上节课是远程克隆到本地，如果我们本地已经有了一个仓库的话怎样才能把它放到远程仓库里面呢</p>
<p>首先我们还是需要在GitHub上创建一个新的仓库，叫first-repo，之前我们创建过一个叫做my-repo的本地仓库，那现在我们就来把my-repo这个本地仓库和刚刚在GitHub上创建的远程仓库关联起来，新创建的时候github已经提示了我们需要使用 git remote add<shortname><url> 这个命令，它的意思就是添加一个远程仓库，这里的orgin就是我们远程仓库的别名，.一般默认的别名都是这个，也可以自己指定一个其他的名字，复制第一行到终端，再使用 git remote -v这个命令来查看一下，这个命令可以查看我们当前仓库所对应的远程仓库的别名和地址，可以看到我们现在本地仓库所对应的远程仓库别名叫做origin</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025183411408.png" alt="image-20251025183411408"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025184223858.png" alt="image-20251025184223858"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-repo</span><br><span class="line">git remote add origin git@github.com:shelterlq77-bit/first-repo.git</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>那第二行的最会的意思是指定分支的名称为main，因为我们这里默认的分支名称就是main，所以这一行的命令我们可以省略掉，最后一行就是把我们本地的main分支和远程的origin仓库的main分支关联起来，其实这个命令的全称应该是这样写的，-u是upstream的缩写，它的意思就是把我们本地仓库和别名为origin的远程仓库关联起来，后面的main:main就是把本地仓库的main分支推送给远程仓库的main分支。如果本地分支的名称与远程分支的名称相同的话我们就可以省略只写一个main就可以了，回车之后它会提示我们输入密码，回到页面就成功推送了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#git push -u origin main:main</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p>同样地 如果我们在远程仓库修改了一些内容，那么就需要使用pull命令来把远程仓库的修改拉取到本地，GitHub上的文件是可以直接在线编辑的，比如我们可以在这里添加一个新的文件来模拟一下远程仓库的修改，添加一个readme，当我们访问一个仓库地址的时候这个仓库的首页就会显示这个README文件中的内容，这样可以添加一些介绍</p>
<p>然后使用pull来拉取一下远程仓库的修改内容，这里面仓库的名称和分支的名称可以省略，如果省略的话默认就是拉取仓库别名为origin的main分支，它的作用就是把远程仓库的指定分支拉取到本地再进行合并，我们可以cat一下这个文件的内容和远程仓库的内容是一样的。</p>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025185008201.png" alt="image-20251025185008201" style="zoom:50%;" />

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin</span><br></pre></td></tr></table></figure>

<p>需要注意的一点就是在执行完 git pull 之后，Git会自动为我们执行一次合并操作，如果远程仓库中的修改内容和本地仓库中的修改内容没有冲突的话那么合并操作就会成功，否则会因为冲突而失败，需要手动来解决一下冲突，从远程仓库获取内容还可以使用fetch命令，它们的区别在于fetch命令只是获取远程仓库的修改，但是并不会自动合并到本地仓库中，而是手动合并，后面会讲</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025185406549.png" alt="image-20251025185406549"></p>
<h1 id="Gitee的使用和GitLab本地化部署"><a href="#Gitee的使用和GitLab本地化部署" class="headerlink" title="Gitee的使用和GitLab本地化部署"></a>Gitee的使用和GitLab本地化部署</h1><p>Gitee就是国内的平台，GitLab私有化比较好</p>
<p>Gitee的中文名称叫码云，设置-ssh秘钥，其他的都差不多</p>
<p>GitLab私有化部署：所谓的私有化部署就是我们可以在自己的服务器上部署一个GitLab代码托管服务，那老师这里是使用Docker部署在了自己电脑本地，部署的过程可以参考GitLab的官方文档</p>
<p>部署就不演示了，启动服务之后我们可以在浏览器中输入localhost来访问我们的GitLab服务，登录之后我们可以在右上角的个人头像弹出菜单里面找到偏好设置选项，在里面可以找到语言设置，中文，添加ssh秘钥也是一样</p>
<p>我们重点来看一下如何在私有化的GiLab服务器上创建一个仓库，我们可以在右上角的加号里面找到新建项目，这里选择创建空白项目，项目标识就使用local-gitlab，输入项目标识和项目的可见性级别，然后新建项目成功创建</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025190241723.png" alt="image-20251025190241723"></p>
<p>点击克隆按钮的复制链接地址 复制一下我们仓库的地址，然后在命分行执行一下 git clone 命令，后面加上我们的地址。我们也可以把本地一个已经存在的仓库推送到GitLab服务器上，比如我们选择之前创建的my-repo这个仓库，我们可以使用 git remote -v 这个命令来查看它目前关联的远程仓库的<br>地址，那也可以使用 git remote add 这个命分来添加新的远程仓库，后面加上仓库的别名和地址，回车之后我们再次使用 git remote -v 来查看一下，可以看到除了原本关联到GitHub上的origin之外，我们现在又多了一个名字叫gitlab的远程仓库，它所对应的地址就是刚刚我们在GitLab上创建的仓库地址，也就是说我们现在的my-repo这个本地仓库同时关联了公有的GitHub和私有的GitLab</p>
<p>那现在比如说我们在本地修改了一些文件提交之后，在执行推送的时候，我们可以使用 git push 后面不加任何参数来推送到GitHub上，因为我们的本地仓库默认关联的是GitHub，那也可以使用 git push 加上gitlab和main分支来推送到我们私有的GitLab上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> xxxxx</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">cd</span> local-gitlab</span><br><span class="line"><span class="built_in">ls</span> -al</span><br><span class="line">git remote -v</span><br><span class="line">git remote add gitlab xxxx</span><br><span class="line">git push gitlab main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="GUI工具"><a href="#GUI工具" class="headerlink" title="GUI工具"></a>GUI工具</h1><p>打开官网，GitHub Desktop是GtHub官方出品的图形化工具，它与GitHub整合的比较好，界面简洁，但是功能非常的单一，只能用来管理GitHub上的仓库，一些高级功能比如分支管理等等都支持的不是特别好，如果你只是想要一个简单的图形化工具，而且只是想要管理GttHub上的仓库的话，那么GitHub-desktop的功能是基本够用的</p>
<p>Sourcetree，Sourcetree是由Atlassian公司出品的款免费的GUI工具，Sourcetree同样也支持Windovs和Mac操作系统</p>
<p>接下来我们看一下Gitkraken，Gitkraken是由Axosoft出品的一款商用版的图形化工具，它也提供了免费的个人使用版，但是免费版本的功能有限，比如你的仓库如果关联了私有仓库那免费无法使用，这家公司还提供一款叫做GitLens的VSCode扩展，可以在VSCode中使用图形化的功能，它还提供Git和jIRA的集成，但是这些功能都分为免费版和收费版<br>弹幕推荐：lazygit</p>
<h1 id="VSCODE使用git"><a href="#VSCODE使用git" class="headerlink" title="VSCODE使用git"></a>VSCODE使用git</h1><p>搜索git，下载git graph，然后左边有个源代码管理器，可以在源码管理器中看到仓库的状态，比如我们来修改一下仓库中的文件，保存之后就可以看到源码管理器的图标上面多了一个数字的角标1，表示我们的仓库中有一个更改内容，我们可以点击这个图标就会定位到我们刚刚修改过的文件，点击这个文件就可以看到这个文件的具体修改内容</p>
<p>其实这个比较的差异内容就是我们之前讲过的 git diff 命令的输出结果，这样看起来的话要比命令行的加加减减更加直观一些</p>
<p>在文件名的右侧有四个小图标，第一个图标表示打开文件，点击之后就会打开对应的文件，第二个图标表示放弃更改，点击之后就会丢弃这个文件还没有提交的更改内容，第三个图标表示添加到暂存区，也就是我们之前所学习的 git add 命令，点一下加号之后这个文件就会从更改列表消失，变成暂存的更改。最后这个图标表示了当前文件的状态，这里的 M 表示这个文件已经被修改过了，其他状态还有 A和 D，表示新建的文件和已经删除的文件，和我们使用 git status 命令看到的结果是一样的</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025233041387.png" alt="image-20251025233041387"></p>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025233425125.png" alt="image-20251025233425125" style="zoom:50%;" />

<p>我们可以使用 VSCode 来新建一个文件，在资源管理器右边点击新建按钮，可以点击这里的选择语言来设置语言种类，VSCode会使用对应的语言包来进行语法高亮和代码提示，比如这里我们输入一个html，然后在文件中输入一个html:5的标签，输入!再按下tab就会按照HTML5的语法格式来自动补全文档的内容，然后我们来保存一下这个文档</p>
<p>保存之后就可以在源码管理器中看到这个文件，右侧的 U表示这个文件当前处在一个未被跟踪的状态，回到管理器，这个文件显示在未跟踪的更改下面表示这是一个新增的文件，我们可以点击加号把它添加到暂存区，那对应的文件的状态也由未跟踪变成了添加到暂存区，文件的状态也变成了A，表示这是一个新建的文件。同样的 我们也可以来删除一个文件，状态会变成D</p>
<p>在VSCode中的提交操作也非常的方便，就是上面这个蓝色的提交按钮，按钮上面的输入框就是我们的提交信息，也就是使用 git commit -m 后面添加的内容。然后点击提交按钮我们的代码就可以提交到本地仓库中了，接下来这个按钮变成了 同步更改，提示我们是否需要把这个提交推送到远程仓库，点击的话就直接推送到远程默认的 origin&#x2F;main 分支，那这里的上箭头表示推送操作，如果远程仓库有更新的内容的话这里它也会提示我们，这个箭头就会变成一个下箭头</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251025234723341.png" alt="image-20251025234723341"></p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>我们可以把它看作是代码库中的不同版本，可以独立存在 并且有自己的提交记录</p>
<p>分支非常适合团队协作和开发管理，比如多个开发人员可以在自己的分支上进行开发工作，最后再合并到主线代码库中，我们也可以在一个分支上进行新功能的开发，或者建立一个问题修复的分支来处理一些bug和缺陷，这样就可以让主线代码仓库处于一个随时可用的比较稳定的状态，而不会影响到其他功能的开发和测试，保证了项目的正常运行和高效协作</p>
<p>分支的优点就是能够提高团队协作的效率，减少冲突和错误的影响，让团队中的每个人都能够独立开发和测试，接下来我们就来一起看一下Git中分支的一些基本操作</p>
<p>首先我们来创建一个branch-demo的文件夹，然后来初始化一个仓库，我们使用分支名加序号来命名文件，使用分支名加冒号加序号的方式来编写提交记录，这样看起来更加直观和容易理解。然后我们使用GitKraken来打开仓库，这样就可以看到每次执行命令之后的变化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> branch-demo</span><br><span class="line"><span class="built_in">cd</span> branch-demo</span><br></pre></td></tr></table></figure>

<p>然后新建三个main文件，提交加上:1表示这是main分支的第一次提交，我们可以通过 git branch命含来查看当前仓库的所有分支，在GitKraken界面中的这个位置也可以看到分支的情况，其他工具比如VsCode也有类似的功能，在命令行的回显中前面带有星号的就是我们目前所处在的分支</p>
<p>到目前为止 我们的仓库中只有一个分支，main默认分支，实际开发过程中，项目经理会把不同的功能分配给不同的开发人员，比如说我们的项目经理把一个新的开发任务分配给我们，我们可以使用 git brapch后面加上分支名来创建一个新的分支，或者也可以点击Gitkrakee界面上的这个位置的分支按钮，然后输入新的分支的名字也是一样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> main1 &gt; main1.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;main:1&quot;</span></span><br><span class="line">略</span><br><span class="line">git branch dev</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251026001715724.png" alt="image-20251026001715724"></p>
<p>那现在我们可以看到这个新的分支已经创建完成了，可以在这个分支上进行开发和测试，这里需要注意的是git branch 命令只是创建了一个新的分支，并没有切换到这个新的分支上，可以使用 git checkout,后面加上分支的名称来切换到不同的分支，可以看到我们的命含提示符已经变成了dev。</p>
<p>使用git checkout命令来切换分支的时候存在的潜在问题：因为除了切换分支和状态之外git checkout命令还可以用来恢复文件或者目录到之前的某一个状态，恢复的时候如果分支名称和文件名称相同的话就会出现歧义，git checkout 命令会默认切换分支而不是恢复文件，Git官方在2.23版本开始为我们提供了一个新的命令git switch，它是专门用来切换分支的，语义更加明确，我们可以使用 git switch 来试一下，可以看到也成功地切回到了main分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git switch dev</span><br></pre></td></tr></table></figure>

<p>那现在假如测试完成没有问题之后我们就需要把这个dev功能的分支合并到主线代码中，我们可以使用git merge命令来将不同的分支合并到当前分支中，merge后面的分支名称是将要被合并的分支，而我们当前所在的分支就是合并后的目标分支，比如说我们要把dev分支合并到main分支中的话，就需要首先切换到main分支，然后执行git merge dev命令，这样就可以把dev分支合并到main分支中了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure>

<p>回车之后Git会自动为我们产生一次提交，我们需要输入提交的消息，直接使用默认的提交信息保存，在GitKraken的分支图上可以看到dev分支和main分支已经合并了，它也非常形象地展示了分支合并的过程，其实这个分支图就是我们提交记录的一个可视化的展示，在命令行中也可以通过 ,gitlog 来查看我们的分支图</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure>

<p>合并完成之后我们再来使用git branch 命令来看一下，可以看到这个dev分支还是存在的，这里有的同学可能会有一些误解，认为分支被合并之后就会消失掉，其实如果我们不手工删除这个分支的话还是会存在，如果分支不再需要，就可以使用 git branch -d 命令来删除这个分支，这里的 -d 参数表示删除已经完成合并的分支，意思就是如果一个分支已经被合并到其他分支中了，那么我们就可以使用这个命令来删除这个分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>

<p>但是如果没有被合并的话是不能使用这个小d参数来删除的，这个时候就需要使用 git branch 后面加上大写字母的 -D 命令来强制删除这个分支<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251026003143947.png" alt="image-20251026003143947"></p>
<h1 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h1><p>如果两个分支修改了同一个文件的同一行代码，Git就不知道应该保留哪个分支的修改内容了，这个时候就需要我们手动来解决冲突</p>
<p>我们还是使用上一节课的仓库，新建一个分支feat，分支的命名其实也是有一定规则和含义的，feat就是feature的缩写，一般用来表示开发某一个功能的分支，然后我们切换到feat分支，我们来修改-下main1.txt文件中的内容，添加一行“这是feat分支中添加的内容”，保存之后我们来提交一下，提交信息我们使用 feat:1表示这是feat分支的第一次提交，技巧：就是在提交命令后面加上-a参数，就可以一个命令完成添加暂存和提交两个动作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch feat</span><br><span class="line">git switch feat</span><br><span class="line">vi main1.txt</span><br><span class="line">git commit -a -m <span class="string">&quot;feat:1&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后我们切换回main分支，我们在main分支里面也同样修改一下这个文件中的内容，当切换回main分支之后，工作区的文件内容也自动发生了变化，刚刚在feat分支添加的内容就消失不见了，因为在main分支中我们还没有对这个文件进行修改，所以切换回main分支之后Git自动为我们把工作区域的内容也恢复了，同样也在第二行加上一句话“xxxx”，然后同样也来保存提交一下，这里 -a -m 也可以省略成-am，这个时候就可以看到feat分支和main分支的修改内容产生了分歧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git switch main</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">vi main1.txt</span><br><span class="line">git commit -am <span class="string">&quot;main:6&quot;</span></span><br></pre></td></tr></table></figure>

<p>那现在我们来尝试合并一下分支，输入 git merge 来把feat分支的内容合并到main分支，回车之后 Git就会提示我们产生了冲突，自动合并失败了，需要解决冲突之后再提交，现在我们也可以使用 git status 命令来查看一下冲突文件的列表，也可以使用 git diff 命令来查看冲突的具体内容，Git会把两个分支的修改内容全都显示出来</p>
<p>然后Git会使用左箭头 等号和右箭头分别来表示两个分支的修改内容，其中等号上面的部分表示我们刚刚main分支中的修改内容，而等号下面到右箭头之间的部分是我们刚刚在feat分支中添加的内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge feat</span><br><span class="line">git status</span><br></pre></td></tr></table></figure>

<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251026025650819.png" alt="image-20251026025650819" style="zoom: 67%;" />

<p>那现在我们需要做的就是需要手工编辑这个文件，留下我们想要的内容之后然后再重新提交，我们把左箭头 等号和右箭头都去掉，把第二行的内容合并到第一行后面，然后添加一个逗号，这样我们就把两个分支的修改内容合在了一起，然后保存退出，然后添加暂存提交，可以看到提交之后就自动完成了我们合并的过程</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251026030013097.png" alt="image-20251026030013097"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi main1.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;merge conflict&quot;</span></span><br></pre></td></tr></table></figure>

<p>在提交之前如果想中断这次合并的话，我们也可以使用 git merge  –abort 这个命令来终止合并</p>
<h1 id="回退和rebase"><a href="#回退和rebase" class="headerlink" title="回退和rebase"></a>回退和rebase</h1><p>除了merge以外还有另外一个方法可以将不同分支的修改内容整合到一起，就是rebase，中文意思是变基</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/NoteImg/Git/git/image-20251026030422878.png" alt="image-20251026030422878"></p>
<p>之前因为上一范课演示合并冲突的时候新建了一个feat分支，那我们先将这个feat分支删除掉，避免它干扰我们的演示，执行 git branch -d feat 命令就可以了，还有在之前合并完成之后我们已经把dev分支删除掉了，那么现在就需要把它恢复回来，执行gie checkout -b dev，后面加_dev:2这次提交的提交ID，这样就可以恢复到这个分支的这一时间点的状态，那这个提交ID可以在GitKraken中看到，如果没有的话 就在标题中点一下右键然后选中这个Sha，也可以在命令行中使用 git log 命令来查看</p>
<p>这个命令太长了可以使用alias命令来将它定义成一个别名，比如这里我们将它定义成graph，这样以后我们就可以直接使用graph命令来查看图形化的提交记录了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feat</span><br><span class="line">gie checkout -b dev</span><br><span class="line">git <span class="built_in">log</span> --oneline --graph --decorate --all</span><br><span class="line"><span class="built_in">alias</span> graph=<span class="string">&quot;git log --oneline --graph --decorate --all&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后我们再切换回main分支</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Shelter67">Shelter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://localhost:4000/posts/518e617c.html">http://localhost:4000/posts/518e617c.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://localhost:4000" target="_blank">Shelter</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/git/">git</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.dreamshelter.cn/blog/source/img/cover/29.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/73ab5b62.html" title="快速学习Linux"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/blog/source/img/cover/5.jpg" onerror="onerror=null;src='https://cdn.dreamshelter.cn/blog/source/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">快速学习Linux</div></div><div class="info-2"><div class="info-item-1">12345678#启动vimvi hello.txt#查看文件夹ls#查看文件内容cat hello.txt    进入时是命令模式，冒号是尾行模式的前缀，:q是退出，q是quit   上图是命令模式每个按键的作用，下图是光标移动       p键也可以把刚刚删除的内容粘贴到这里 输入2yy可以复制两行，2就是表示复制或者粘贴的次数     12345678910111213141516171819202122232425262728#显示行号:set number:set nu#缩写#关闭行号:set nonumber#快速地跳转到文件的最后一行G#跳转到文件的第一行gg#跳转到文件中指定的某一行行号G:行号#输入#查找（输入，区分大小写，内容后面\c可以忽略大小写）/内容#从光标位置开始向下查?内容#从光标位置向上查n#继续向下或向上查N#和n相反#替换:数字,数字s/Hello/world/g#从第几行到第几行，第二个数字换成$就是最后一行，替换当前行就忽略数字，s是替换，后面是被替换的内容，g是全局，不加g只会替换每一行的第一个匹配到的内容。#撤销（undo）u  常用命...</div></div></div></a><a class="pagination-related" href="/posts/5cbbfd6.html" title="一小时kafka"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/blog/source/img/cover/30.png" onerror="onerror=null;src='https://cdn.dreamshelter.cn/blog/source/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">一小时kafka</div></div><div class="info-2"><div class="info-item-1">简介kafka是开源的分布式事件流处理平台 可以使用kafka作为消息中间件，将服务之间的通信和数据交换解耦，每个服务可以将自己的操作封装成一个事件，比如用户下单之后，订单服务会产生一个订单已创建事件，订单服务就是一个生产者，然后这个事件会被发送到卡夫卡中，库存 积分 支付等等其他服务就可以订阅这个事件，它们也就是消费者 Consumer，当他们准备好的时候就可以从Kafka中读取这个事件并进行处理，这种模式就是我们常说的生产者消费者模式。 一些服务作为生产者来产生事件，其他服务作为消费者来处理事件，中间的Kafka就是一个消息队列，将生产者和消费者解耦，每个事件在Kafka中都有一个唯一的序号叫做offset，用来标识事件的位置，消费者可以通过offset来跟踪已消费的事件，确保不会重复消费或者漏消费，而且这些事件会被持久化到Kafka中，即使某个服务暂时不可用也不会丢失数据，等到服务恢复后就可以从上一次的offset开始继续处理。 在实际业务中不同服务的速度可能会有差异，比如订单服务可能处理得比较快，而支付服务可能处理得比较慢，这就会导致消费者的处理速度跟不上生产者的发送速度...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/blog/source/img/touxiang.jpg" onerror="this.onerror=null;this.src='https://cdn.dreamshelter.cn/blog/source/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Shelter</div><div class="author-info-description">记录自己的成长日志</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Shelter67"><i class="fab fa-github"></i><span>没有什么star的github</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Shelter67" target="_blank" title="GitHub"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1830191738@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/8416212" target="_blank" title="Bilibili"><i class="fab fa-bilibili" style="color: #fb7299;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的小小博客！都是基于hexo框架使用，魔改了一些地方，表现得有些二次元，有个博客希望能在未来工作简历上成为加分项吧，但是弄起来还真的挺好玩的</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">安装配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text">新建版本库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">4.</span> <span class="toc-text">Git的工作区域和文件状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%8F%90%E4%BA%A4%E4%BB%93%E5%BA%93"><span class="toc-number">5.</span> <span class="toc-text">添加提交仓库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git-reset%E5%9B%9E%E9%80%80%E7%89%88%E6%9C%AC"><span class="toc-number">6.</span> <span class="toc-text">git reset回退版本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git-diff"><span class="toc-number">7.</span> <span class="toc-text">git diff</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git-rm-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">git rm 删除文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6"><span class="toc-number">9.</span> <span class="toc-text">.gitignore忽略文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E5%86%8Cgithub%E8%B4%A6%E5%8F%B7"><span class="toc-number">10.</span> <span class="toc-text">注册github账号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SSH%E9%85%8D%E7%BD%AE%E5%92%8C%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93"><span class="toc-number">11.</span> <span class="toc-text">SSH配置和克隆仓库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">12.</span> <span class="toc-text">关联本地仓库和远程仓库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gitee%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8CGitLab%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2"><span class="toc-number">13.</span> <span class="toc-text">Gitee的使用和GitLab本地化部署</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GUI%E5%B7%A5%E5%85%B7"><span class="toc-number">14.</span> <span class="toc-text">GUI工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VSCODE%E4%BD%BF%E7%94%A8git"><span class="toc-number">15.</span> <span class="toc-text">VSCODE使用git</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%94%AF"><span class="toc-number">16.</span> <span class="toc-text">分支</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81"><span class="toc-number">17.</span> <span class="toc-text">解决合并冲突</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E9%80%80%E5%92%8Crebase"><span class="toc-number">18.</span> <span class="toc-text">回退和rebase</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/da77c56c.html" title="MVC架构设计模式"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/blog/source/img/cover/12.jpg" onerror="this.onerror=null;this.src='https://cdn.dreamshelter.cn/blog/source/img/404.jpg'" alt="MVC架构设计模式"/></a><div class="content"><a class="title" href="/posts/da77c56c.html" title="MVC架构设计模式">MVC架构设计模式</a><time datetime="2026-11-14T16:24:00.000Z" title="发表于 2026-11-15 00:24:00">2026-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e25feb6e.html" title="黑马程序员SSM"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/blog/source/img/cover/25.jpg" onerror="this.onerror=null;this.src='https://cdn.dreamshelter.cn/blog/source/img/404.jpg'" alt="黑马程序员SSM"/></a><div class="content"><a class="title" href="/posts/e25feb6e.html" title="黑马程序员SSM">黑马程序员SSM</a><time datetime="2026-02-03T03:14:00.000Z" title="发表于 2026-02-03 11:14:00">2026-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eedaddf.html" title="博客笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/blog/source/img/cover/10.png" onerror="this.onerror=null;this.src='https://cdn.dreamshelter.cn/blog/source/img/404.jpg'" alt="博客笔记"/></a><div class="content"><a class="title" href="/posts/eedaddf.html" title="博客笔记">博客笔记</a><time datetime="2026-02-03T02:50:00.000Z" title="发表于 2026-02-03 10:50:00">2026-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5764bc58.html" title="饱了么前端"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/blog/source/img/cover/26.jpg" onerror="this.onerror=null;this.src='https://cdn.dreamshelter.cn/blog/source/img/404.jpg'" alt="饱了么前端"/></a><div class="content"><a class="title" href="/posts/5764bc58.html" title="饱了么前端">饱了么前端</a><time datetime="2026-02-03T02:50:00.000Z" title="发表于 2026-02-03 10:50:00">2026-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2821e645.html" title="饱了么后端"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.dreamshelter.cn/blog/source/img/cover/17.jpg" onerror="this.onerror=null;this.src='https://cdn.dreamshelter.cn/blog/source/img/404.jpg'" alt="饱了么后端"/></a><div class="content"><a class="title" href="/posts/2821e645.html" title="饱了么后端">饱了么后端</a><time datetime="2026-02-03T02:50:00.000Z" title="发表于 2026-02-03 10:50:00">2026-02-03</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Shelter</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="/js/tw_cn.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://blog.dreamshelter.cn/twikooapi/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://blog.dreamshelter.cn/twikooapi/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script><div class="aplayer no-destroy" data-id="17745883873" data-server="netease" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="true" data-mutex="true" ></div><script id="canvas_nest" defer="defer" color="255,192,203" opacity="0" zIndex="-1" count="80" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href=".aside-content"]):not([href="#aside-content"]):not([href=".card-clock
# Inject the css and script (aplayer/meting) aplayerInject: enable: true per_page: true
# 通知弹窗 # Snackbar - Toast Notification # https://github.com/polonel/SnackBar # position: top-left / top-center / top-right / bottom-left / bottom-center / bottom-right snackbar: enable: true position: top-right # The background color of Toast Notification in light mode and dark mode bg_light: "])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      false
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="app-refresh" style="position: fixed; top: -2.2rem; left: 0; right: 0; z-index: 99999; padding: 0 1rem; font-size: 15px; height: 2.2rem; transition: all 0.3s ease;"><div class="app-refresh-wrap" style="display: flex; color: #fff; height: 100%; align-items: center; justify-content: center;"><label>🚀 有新内容发布啦！</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color: #fff; text-decoration: underline; cursor: pointer; margin-left: 8px;">点击刷新</span></a></div></div><script>if ('serviceWorker' in navigator) {
  // 如果当前页面受 Service Worker 控制，监听控制权变化
  if (navigator.serviceWorker.controller) {
    navigator.serviceWorker.addEventListener('controllerchange', function() {
      showNotification();
    });
  }

  // 页面加载完成后注册 sw.js
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/sw.js').catch(err => {
      console.error('PWA 注册失败:', err);
    });
  });
}

function showNotification() {
  // 优先使用主题自带的 Snackbar 弹窗
  if (window.GLOBAL_CONFIG && GLOBAL_CONFIG.Snackbar) {
    var snackbarBg = document.documentElement.getAttribute('data-theme') === 'light' ?
      GLOBAL_CONFIG.Snackbar.bgLight :
      GLOBAL_CONFIG.Snackbar.bgDark;
    
    var snackbarPos = GLOBAL_CONFIG.Snackbar.position;

    Snackbar.show({
      text: '🚀 有新文章发布啦！',
      backgroundColor: snackbarBg,
      duration: 10000, // 持续 10 秒
      pos: snackbarPos,
      actionText: '点击刷新',
      actionTextColor: '#fff',
      onActionClick: function(e) {
        location.reload();
      },
    });
  } else {
    // 如果没有 Snackbar，则显示顶部的 app-refresh 栏
    var showBg = document.documentElement.getAttribute('data-theme') === 'light' ? '#49b1f5' : '#1f1f1f';
    var appRefresh = document.getElementById('app-refresh');
    if (appRefresh) {
      appRefresh.style.cssText = 'top: 0; background: ' + showBg + ';';
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索点什么呢………" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div><!-- hexo injector body_end start -->
  <script data-pjax src="/js/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://vercelapi.dreamshelter.cn/api?user=shelter67";
            var git_color =['#ebedf0', '#a2f7af', '#6ce480', '#54ad63', '#469252', '#31753c', '#1f5f2a', '#13531f', '#084111', '#032b09', '#000000'];
            var git_user ="shelter67";
            var parent_div_git = document.getElementsByClassName('layout')[0];
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/gongxianban/'){
                console.log("已挂载hexo-github-calendar https://github.com/Barry-Flynn/hexo-github-calendar");
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementsByClassName('layout')[0]){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><script data-pjax>
function hexo_butterfly_clock_remake_injector_config(){
  var parent_div_git;
  var item_html = `<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-veeink@1.0.7/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>`;

  // 按类型获取容器
  if ('class' === 'class') {
    parent_div_git = document.getElementsByClassName('aside-content')[0];
  } else if ('class' === 'id') {
    parent_div_git = document.getElementById('aside-content');
  } else {
    parent_div_git = document.getElementById('aside-content');
  }

  if(parent_div_git){
    var reference_el_before = null;
    var reference_el_after = parent_div_git.querySelector('.card-announcement');

    if(reference_el_before){
      parent_div_git.insertBefore(
        (function(){var temp = document.createElement('div'); temp.innerHTML = item_html; return temp;}()),
        reference_el_before
      );
    } else if(reference_el_after){
      reference_el_after.insertAdjacentHTML('afterend', item_html);
    } else {
      parent_div_git.insertAdjacentHTML('afterbegin', item_html);
    }
  }
}

console.log('已挂载 butterfly_clock_anzhiyu-yang 修复版');

// ---------- 全局变量声明 ----------
var cpage = location.pathname;
var epage = 'all';
var qweather_key = '0df3cf714a324957b16f3201e86fe931';
var qweather_api_host = 'https://p65ctvhqy4.re.qweatherapi.com';
var default_city = '';
var gaud_map_key = '296709bdb591a3523a2cf60e8e8f0ba3';

// ---------- 页面过滤 ----------
var elist = 'null'.split(',');
var flag = 0;
for(var i=0;i<elist.length;i++){
  if(cpage.includes(elist[i])) flag++;
}

if((epage === 'all') && (flag == 0)){
  hexo_butterfly_clock_remake_injector_config();
} else if(epage === cpage){
  hexo_butterfly_clock_remake_injector_config();
}
</script><script data-pjax src="/js/clock-min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementsByClassName('footer-other')[0];
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v8.1.1" title=""><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v5.5.4" title=""><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://cloud.tencent.com/" style="margin-inline:5px" data-title="本站由腾讯云提供服务器支持" title=""><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Server-Tencent%20Cloud-00A4FF?style=flat&amp;logo=qq&amp;logoColor=white" alt=""/></a><a class="github-badge" target="_blank" href="https://edgeone.ai/" style="margin-inline:5px" data-title="本站由腾讯云 EdgeOne 提供安全加速" title=""><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-EdgeOne-00A4FF?style=flat&amp;logo=iCloud&amp;logoColor=white" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/" style="margin-inline:5px" data-title="工业和信息化部ICP备案管理系统" title=""><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E9%B2%81ICP%E5%A4%87-2025199346%E5%8F%B7--1-ba9132?style=flat&amp;labelColor=443d38" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://www.fomal.cc/static/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>